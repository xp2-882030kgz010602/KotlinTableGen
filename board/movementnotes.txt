v        <-top head; writes new tiles into the column then advances as needed after the bottom head does its work; initialize this on the "leftmost" tile (see below)
X X X X X X X  <-the column we want to apply a move function to; define "left" as the direction in which tiles are moving
^        <-bottom head; reads out a tile, sets that tile to blank, then advances each loop; initialize this on the "leftmost" tile
X        <-one-tile "register"; initialize this as blank (zero)

v
2 2 2 _ 4 4 2  Rule 0: If the register is blank, the bottom head just overwrites the register
^        (these rule numbers are arbitrary and these rules don't need to be applied in any specific order)
_

v
_ 2 2 _ 4 4 2  Rule 1: If the register and the readout are equal and nonzero, we write the next tile with the top head and clear the register
  ^
2

  v
4 _ 2 _ 4 4 2  Apply rule 0
    ^
_

  v
4 _ _ _ 4 4 2  Rule 2: If the readout is blank, do nothing (this is compatible with rule 1 when both the register and readout are zero)
      ^
2

  v
4 _ _ _ 4 4 2  Rule 3: If the register and the readout are unequal and nonzero, we copy the register into the column with the top head and copy the readout into the register
        ^
2

    v
4 2 _ _ _ 4 2  Apply rule 1
          ^
4

      v
4 2 8 _ _ _ 2  Apply rule 0
            ^
_

      v
4 2 8 _ _ _ _  Finish by copying anything in the register into the column with the top head
        ^  Buffer overflow is impossible because we can never write more tiles using the top head than are in the column
2        It is true that we could have up to n+1 writes with the top head, but we cannot end up with n+1 tiles to write, and the top head only advances after writing

        v
4 2 8 2 _ _ _
        ^
_